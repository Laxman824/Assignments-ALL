# -*- coding: utf-8 -*-
"""annealingipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HCpKGb5FOwvu1VtDZcg4Z22EQNLmi1zD
"""

import numpy as np
def TSP_SA(G):                             #here G is the matrix of the input graph 
   soln = list(range(len(G)))
   c = cost(G, soln)
   ntrial = 1                             #starting with trail =1
   T = 30                                 #setting the temparature 
   alpha = 0.99                           #rate of which temparature should decrease  
   while ntrial <= 1000:                  #number of iterations till 1000
      n = np.random.randint(0, len(G))    #initially taking  a random b\w
      while True:                         #m,n are the initial randomly choosen positions 
         m = np.random.randint(0, len(G))
         if n != m:                       #takig other m which is not equal to previously taken vertex
            break
      s1 = swap(soln, m, n)                  #swap two vertexes to get explore 
      c1 = cost(G, s1)                    #finding the cost of the 
      if(ntrial%50 == 0):
        print(s1)
        print(c1)
      if c1 < c:                          # comparing the cost of c1(current cost) with previous 
         soln, c = s1, c1                    # if it is better replace the best with current
      else:
         if np.random.rand() < np.exp(-(c1 - c)/T):  #allow but if it satisfies acceptance probability
            soln, c = s1, c1                 #exp()
      T = alpha*T                         #if it doesnt satisfy just decrease the temp with alpha and increase the iteration &repeat
      ntrial += 1
  #  print("The Tsp path computed with simulated annealing ")
   print("The best solution found is :")
   print(soln)

   print(c)
def swap(soln, m, n):
   i, j = min(m, n), max(m, n)
   s1 = soln.copy()
   while i < j:
      s1[i], s1[j] = s1[j], s1[i]
      i += 1
      j -= 1
   return s1
  
def cost(G, soln):
   l = 0
   for i in range(len(soln)-1):
      l += G[soln[i]][soln[i+1]]
   l += G[soln[len(soln)-1]][soln[0]] 
   return l
def main():
  print("TSP computation of path starts here ")
  G = [
        [0, 200, 500, 650, 600, 150],
        [200, 0, 250, 700, 750, 300],
        [500, 250, 0, 150, 400, 500],
        [650, 700, 150, 0, 100, 200],
        [600, 750, 400, 100, 0, 150],
        [150, 300, 500, 200, 150, 0]]

  TSP_SA(G)


if __name__ == "__main__":
  main()


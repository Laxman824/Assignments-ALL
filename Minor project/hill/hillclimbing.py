# -*- coding: utf-8 -*-
"""hillclimbing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZsMoVl-Fnx_c1m-yxVvaeccAoz97iNpX
"""

import random 

def initial_config(tsp): #here tsp is the list of cities 

  cities = list(range(len(tsp)))
  print(cities)

  solution = []  #solution is used to store thelist of all cities in a order

  for i in range(len(tsp)):

    randomcity =cities[random.randint(0,len(cities)-1)] #choosing one city out of the list 
    
    solution.append(randomcity) # adding city to solution array
    
    cities.remove(randomcity)   #remvoing the city from city identifier list
    
  #print('random arrangement: ', solution)
  
  return solution

def distance(tsp,solution): #used for finding the length of route

  distance = 0              #
  
  for i in range(len(solution)):

    distance += tsp[solution[i-1]][solution[i]]

  return distance

def findnext(solution): #finding neighbour that only sightly different from current solution

  neighbours = []

  for i in range(len(solution)):#loop thoroughout the city 

    for j in range(i + 1,len(solution)):#cities the firstloop hasnt looped over yet in this for loop

      neighbour  = solution.copy() #copying the current solution

      neighbour[i] = solution[j]  #swap two cities and this way creating a

      neighbour[j] = solution[i]  #different solution and exploring neighbours

      neighbours.append(neighbour)

  return neighbours #add to the neighbours list

def best_next(tsp,neighbours):

  bestdistance = distance(tsp,neighbours[0]) #starting from 1st place

  bestneighbour =neighbours[0]

  for neighbour in neighbours:

    current_distance = distance(tsp,neighbour)

    if current_distance < bestdistance:#checking current and bestdist

      bestdistance = current_distance #if satisfies replace

      bestneighbour = neighbour

  return bestneighbour , bestdistance

def hillclimbing(tsp):
  currentsolution = initial_config(tsp)  #make a random solution  

  currentdistance = distance(tsp,currentsolution) # calculate routelength/distance

  neighbours = findnext(currentsolution)  #create neighbouring soln

  bestneighbour,bestneighbourdistance  = best_next(tsp,neighbours) #take best out of neighbour

  print('first solution: ', bestneighbour , ', ', bestneighbourdistance)

  while bestneighbourdistance < currentdistance: #repeat the process until bestneighbour is better
                                                #better than current one
    currentsolution = bestneighbour

    currentdistance = bestneighbourdistance

    neighbours =findnext(currentsolution)

    bestneighbour, bestneighbourdistance = best_next(tsp, neighbours)
  
  return currentsolution,currentdistance
  print('current solution: ', bestneighbour , ', ', bestneighbourdistance)

# def problemGenerator(nCities):#here ncities is no.of vertices/cities for salesman
#     tsp = []                 #problemgenerator for creating more vertices and giving random weight 
#     for i in range(nCities):
#         distances = []      #for each city creating a list of distance(randomly)
#         for j in range(nCities):
#             if j == i:     #look for  value if it is already known
#                 distances.append(0)
#             elif j < i:
#                 distances.append(tsp[j][i])
#             else:
#                 distances.append(random.randint(10, 1000))
#         tsp.append(distances)
#     return tsp

def main():
    tsp = [
        [0, 200, 500, 650, 600, 150],
        [200, 0, 250, 700, 750, 300],
        [500, 250, 0, 150, 400, 500],
        [650, 700, 150, 0, 100, 200],
        [600, 750, 400, 100, 0, 150],
        [150, 300, 500, 200, 150, 0]
        # [0,10,20],
        # [10,0,20],
        # [20,30,0]
    ]
    # tsp = problemGenerator(6)#give the no.of vertices count here
    # for i in range(10):
    #   print(hillclimbing(tsp))

    print('----------------------------------------')
    print('\n final solution', hillclimbing(tsp))

if __name__ == "__main__":
    main()